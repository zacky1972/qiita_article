---
title: 並行・並列プログラミングと同期・排他制御とイミュータブル性の話〜その4「イミュータブル性の利点」
tags:
  - Elixir
private: true
updated_at: ''
id: null
organization_url_name: fukuokaex
slide: false
ignorePublish: false
---
大学の授業で講義資料を作ったので，Qiitaにも展開しておきます．

この記事シリーズでは，並行・並列プログラミングについて，要(かなめ)となる同期・排他制御の役割をCとJavaを例に簡単なプログラム例を示します．次に同期・排他制御の問題点をCのプログラム例とともに示します．そしてElixir(エリクサー)によって実現されている，全てをイミュータブルにすることによる利点について示します．

シリーズ

1. [並行・並列プログラミングと同期・排他制御とイミュータブル性の話〜その1「背景: クロック周波数の停滞とコア数の増加」]()
1. [並行・並列プログラミングと同期・排他制御とイミュータブル性の話〜その2「スレッドと同期・排他制御」]()
1. [並行・並列プログラミングと同期・排他制御とイミュータブル性の話〜その3「同期・排他制御の2つの問題点」]()
1. **並行・並列プログラミングと同期・排他制御とイミュータブル性の話〜その4「イミュータブル性の利点」** (本記事)

# 同期・排他制御の問題点おさらい

[前の記事]()にて同期・排他制御を伴う並行・並列プログラミングには2つ問題点があることを指摘しました．

* デッドロックの問題
* 性能低下の問題

# イミュータブル性

Erlangと，Elixirを含むErlang派生言語(BEAM言語)では，全てのデータが **イミュータブル(immutable)** である，つまり不変です．イミュータブルであることによって，同期・排他制御のかなりの部分が不要になり，その結果，これらの問題が起きにくくなっていることを次に説明します．

## 問題の解決

データを複数コアで共有する場合について再び考えます．

![データを複数コアで共有する場合](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/55223/aaf7b574-6a6a-6896-b0fc-adaf65e32bc2.png)

すべてのデータをイミュータブルにした場合，データをコピーしたとしても同一性を保つことができます．したがって，上図において，共有データをコアで持つ場合，その共有データのコピーをそれぞれで持ったとしても，差し支えありません．

これを推し進めると，スレッドのようにデータ(メモリ領域)を共有するのではなく，**プロセス(process)** のようにデータ(メモリ領域)を互いに共有せずに，別途プロセス間通信でデータを交換するような方式にすることができます．BEAM言語ではスレッドではなくプロセスを採用しています．

スレッドよりプロセスの方が独立性が高く，互いにデータを直接共有しないので，同期・排他制御を行う必然性が薄れ，結果としてデッドロックのような問題が起きにくくなります．(ただし，まったく起きないとは言いません．この点については後述します)

また，次の図のように，データを共有しないために，通知に伴う同期・排他制御を行う必要がなくなり，性能低下を防ぐことができます．

![データを共有しないので通知に伴う同期・排他制御を行う必要がなくなり，性能低下を防ぐことができる](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/55223/0933be59-ded1-8673-fbc2-f7de36284d69.png)

コア数が増えれば増えるほど，この恩恵は大きいです．

# データ変換パラダイムへの発展

次に[プログラミングElixir第2版](https://www.ohmsha.co.jp/book/9784274226373/)に書かれている例を元にして，イミュータブル性の利点について説明します．

例えば何らかのプログラミング言語で次のような記述があったとします．

```elixir
count = 99
do_something_with(count)
print(count)
```

直感的には，この`print(count)`により`99`が表示されるものと考えるかもしれません．

しかし，次のような場合は直感に反して`99`が表示されないかもしれません．

* `do_something_with(count)`での`count`が参照渡しであり，かつ
* `do_something_with`関数が`count`を書き換えるような副作用を持つ場合
* あるいは，他のスレッドが`count`を書き換えるような場合

同様に次のプログラムについて考えます．

```elixir
array = [1, 2, 3]
do_something_with(array)
print(array)
```

これも直感的には`print(array)`によって`[1, 2, 3]`を表示しそうに思えます．

しかし，次のような場合は直感に反して`[1, 2, 3]`とは異なる表示結果になるかもしれません．

* `do_something_with`関数で`array`の要素の一部または全てを書き換えたり，追加・削除をしたりしてしまうような場合
* あるいは他のスレッドが`array`の要素を同時に書き換えたり追加・削除したりするような場合

全てのデータがイミュータブルである場合はどうでしょうか．`do_something_with`がどのような操作をしても，`count`や`array`の値が変化するような副作用が発生しないことを保証できます．また他のスレッドがデータを更新することもありません．

このことにより，次の利点が生まれます．

1. 呼び出し先まで追跡しなくても，どの変数の値が等しいのか，どの値を元にして変数を計算したのかを正確に推論することができます．
1. この推論は，実行順序に依らずに一意に定めることができます．
1. すなわち，実行順序に依らず，実行結果である変数値は同一になります．

並行・並列に実行する場合，実行される順序を規定することが難しいので，実行順序に依らず，実行結果が同一であることは，とても望ましい性質です．

イミュータブル性の下(もと)では，実行順序に依らず，実行結果が同一である性質を持つということにより，次のように`Enum.map`関数を用いて書かれた逐次プログラムを，その後の`Flow.map`関数を用いた並列プログラミングに置き換えても，リストの順番が入れ替わることを除けば，実行結果が同一になることが保証されます．

```elixir
1..1_000_000           # 1から1,000,000までの
|> Enum.map(& &1 * 2)  # リストの各要素を2倍して
|> Enum.map(& &1 + 1)  # さらに各要素に1加えたリストを返す
```

```elixir
1..1_000_000
|> Flow.from_enumerable()
|> Flow.map(& &1 * 2)
|> Flow.map(& &1 + 1)
|> Enum.to_list()
```

なお，この利点を得るためには，全てのデータをイミュータブルにする必要があります．

したがって，オブジェクト指向プログラミングと関数型プログラミングなどのような複数のプログラミング・パラダイムを混在させるマルチパラダイムであるようなプログラミング言語では，全てのデータをイミュータブルに統一しない限り，この利点を享受することはできないと考えられます．これが全てをイミュータブルとしているような，シングルパラダイムであるElixirの利点の1つであると考えています．

# Elixirでの並行・並列プログラミングのデータ共有

Elixirでは，並行・並列処理の単位として，メモリを共有するスレッドではなく，独立したメモリを持つプロセスを採用していると言いました．プロセスの間では，データを直接共有しません．

プロセス間でデータを共有するためのプロセス間通信として，次の2通りの方法が用意されています．

* `send`と`receive`
* mnesia，ETS，`persistent_term` のような共有データベース

それぞれ説明します．

## `send`と`receive`

`send`はプロセスを指定してメッセージを送る関数で，`receive`は自プロセスに届いたメッセージを受け取る構文です．

`send`と`receive`の基本的な文法については，下記を参照ください．

https://elixirschool.com/ja/lessons/intermediate/concurrency

メッセージを送り先のプロセスに渡す際に，若干の排他制御を伴うことがありますが，いわゆる非同期通信というもので，`send`関数を呼び出したプロセスは，先方がメッセージを受け取ったことを確認することなく，次のプログラムを実行し続けます．一方，`receive`を実行すると，マッチするメッセージを受け取るまで待ちます．なお，`after`でタイムアウト時間が指定されている場合には，その時間が経過するとタイムアウトします．

前述のFlowはこの仕組みを用いて実装されています．また，標準入出力を含むI/Oへのアクセスもこの仕組みを用いて実装しています．

## 共有データベース

Erlangはデータを共有する特別な仕組みとして，mnesia, ETS, `persistent_term`のような共有データベースを用意しています．Elixirからも使うことができます．

これらは，単一の操作でデッドロックが起きないように，かつデータの一貫性を保つように，自動で同期・排他制御が取られます．

## 結果の同一性について

これらのプロセス間通信を用いた場合には，全てのデータがイミュータブルであるにもかかわらず，必ず同一の結果をもたらすとは限りません．

例えば，並列に動作する2つのプロセスの中で，`send`と`receive`もしくは共有データベースを用いて，他のプロセスと通信をしていたとします．これらのプロセスは並列に動作するので，プロセス間通信が発生する実行順序が不定となり，その影響を受けて，プロセス間通信を踏まえた実行結果が変化します．

ただし，アルゴリズムによっては，同一の結果をもたらすことをある程度保証できる場合があります．その一例が，Flowの場合です．Flowの場合は，`Flow.map`関数等の中で呼び出す関数の中で，別途プロセス間通信をしない限り，リストの順序が入れ替わることはあるものの，`Flow.map`での実行結果は`Enum.map`の実行結果と変わらないことを保証できます．

## デッドロックについて

これらのプロセス間通信を用いた場合，デッドロックを起こす場合があります．

例えば，プロセスAとプロセスBが相互に`send`と`receive`を用いて通信するような場合，設計がまずいと，プロセスAがプロセスBからのメッセージをタイムアウトなしの`receive`で待っているその瞬間に，プロセスBもプロセスAからのメッセージをタイムアウトなしの`receive`で待ち，互いにメッセージが送られてこないので永遠に待ち続けるデッドロックに陥ることがありえます．

しかし，このような状況は，データの更新のために同期・排他制御を行う場合に比べて，回避が容易です．例えば，プロセスからプロセスへのメッセージを一方通行で受け渡すように設計すれば，互いに待ち状態になることはありません．Flowはこのように，デッドロックが起きないようにデータフロー設計がされています．

# まとめ

同期・排他制御は並行・並列プログラミングで重要な役割を演じますが，デッドロックの問題，性能低下の問題を起こします．Elixirでは，全てのデータをイミュータブル(不変)にすることで，かなりの部分の同期・排他制御を不要にすることができ，大部分のデッドロックの問題や性能低下の問題を解決することができます．
