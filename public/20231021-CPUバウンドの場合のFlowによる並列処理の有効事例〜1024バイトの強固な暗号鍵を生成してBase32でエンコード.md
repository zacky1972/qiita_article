---
title: CPUバウンドの場合のFlowによる並列処理の有効事例〜1024バイトの強固な暗号鍵を生成してBase32でエンコード
tags:
  - Elixir
private: false
updated_at: '2023-10-25T07:51:38+09:00'
id: fc317a7aa4a132a33ef3
organization_url_name: fukuokaex
slide: false
ignorePublish: false
---
ElixirのFlowを用いると，極めて簡潔に並列処理を書くことができます．特にI/Oバウンドの場合，威力を発揮します．一方，CPUバウンドの場合には，負荷の軽い処理では逐次処理よりかえって遅くなるため，簡潔かつ有効な事例を示す必要がありました．そこで，本記事では，`:crypto`と`Base`を用いて比較的重たい暗号処理を行わせたFlowによる並列処理を紹介し，有効性を示します．

## 逐次処理版のコード

Elixirではパイプライン演算子を用いることで，上から下へ流れるように読むことができるプログラムコードを記述できるという点が，大きな強みとなっています．以下に1,000,000個の1024バイトの強固な暗号鍵を生成してBase32でエンコードするElixirコードを紹介します．

```elixir
1..1_000_000
|> Enum.map(fn _ -> :crypto.strong_rand_bytes(1024) end)
|> Enum.map(& Base.encode32(&1, case: :lower)) end)
```

このコードをChatGPTに説明してもらいました．

> このElixirコードは、次のような処理を行います：
> 
> 1. `1..1_000_000` の範囲内にある全ての整数（1から1,000,000までの範囲の整数）に対して、以下の処理を行います。
> 
> 2. `:crypto.strong_rand_bytes(1024)` を呼び出して、1024バイトのランダムバイト列を生成します。この関数はErlangの`:crypto`モジュールから提供されるもので、強力な乱数を生成するために使用されます。
> 
> 3. 生成されたランダムバイト列を `Base.encode32/1` 関数を使用して、1024バイトのバイナリデータを1024文字のBase32エンコード文字列に変換します。変換後の文字列は小文字で表現されます（`:lower` オプションが指定されています）。
> 
> 4. 最終的に、1から1,000,000までの整数範囲内の各整数に対して生成されたBase32エンコード文字列のリストが得られます。
> 
> このコードは、非常に大きなランダムなBase32エンコード文字列のリストを生成するもので、それぞれの文字列は1024バイトのランダムデータを表します。このようなランダムデータはセキュリティや乱数生成のアプリケーションで使用されることがあります。
なお，このコードを作る際に参考にした記事は次のとおりです．

https://qiita.com/mnishiguchi/items/90380b61df4e41966556

## 並列処理版のコード

ではFlowによる並列処理にするとどうなるでしょうか．

```elixir
1..1_000_000
|> Flow.from_enumerable()
|> Flow.map(fn _ -> :crypto.strong_rand_bytes(1024) end)
|> Flow.map(& Base.encode32(&1, case: :lower))
|> Enum.to_list()
```

このコードもChatGPTに説明してもらいます．

> このElixirコードは、次の処理を行います：
> 
> 1. `1..1_000_000` の範囲内の整数（1から1,000,000までの整数）に対して以下の処理を行います。
> 
> 2. `Flow.from_enumerable()` 関数を使用して、整数の範囲を `Flow` データフローに変換します。これにより、データフロー処理が可能になります。
> 
> 3. `Flow.map(fn _ -> :crypto.strong_rand_bytes(1024) end)` を使用して、各整数に対して1024バイトのランダムバイト列を生成する処理を実行します。この処理はデータフロー内で並列的に行われ、複数の要素を同時に処理できます。
> 
> 4. `Flow.map(& Base.encode32(&1, case: :lower))` を使用して、生成されたランダムバイト列を1024文字のBase32エンコード文字列に変換する処理を実行します。これもデータフロー内で並列的に行われます。
> 
> 5. 最後に、`Enum.to_list()` を使用して、データフロー内で処理された結果を通常のリストに変換し、そのリストを得ます。
> 
> このコードは、1から1,000,000までの整数範囲内の各整数に対してランダムなBase32エンコード文字列を生成します。`Flow` を使用することで、より効率的な並列処理が行われ、大量のデータを効率的に処理できるようになります。

Flowを用いた時の注意点としては，並列処理をした時の到着順にリストが生成されるので，結果の順番がランダムになることです．この例では，各要素の計算結果は要素の順番に全く依存しないランダムなものなので，特に問題になることはありません．もし到着順ではなく，最初に生成したリストと同じ順番にしたい時には，適宜ソートをする必要があります．

## 実行時間の計測

Bencheeというベンチマークプログラムを使って，逐次版と並列版の実行時間を計測・比較します．

```elixir
Mix.install([:flow, :benchee])

Benchee.run(
  %{
    "sequential execution" => fn -> 1..1_000_000 |> Enum.map(fn _ -> :crypto.strong_rand_bytes(1024) end) |> Enum.map(& Base.encode32(&1, case: :lower)) end,
    "parallel execution" => fn -> 1..1_000_000 |> Flow.from_enumerable() |> Flow.map(fn _ -> :crypto.strong_rand_bytes(1024) end) |> Flow.map(& Base.encode32(&1, case: :lower)) |> Enum.to_list() end
  },
  memory_time: 2,
)
```

```zsh
$ elixir bench.exs
elixir bench.exs
warning: trailing commas are not allowed inside function/macro call arguments
  bench.exs:8:17

Operating System: macOS
CPU Information: Apple M2 Max
Number of Available Cores: 12
Available memory: 96 GB
Elixir 1.15.7
Erlang 26.1.1

Benchmark suite executing with the following configuration:
warmup: 2 s
time: 5 s
memory time: 2 s
reduction time: 0 ns
parallel: 1
inputs: none specified
Estimated total run time: 18 s

Benchmarking parallel execution ...
Benchmarking sequential execution ...

Name                           ips        average  deviation         median         99th %
parallel execution            0.37         2.72 s     ±2.35%         2.72 s         2.76 s
sequential execution          0.30         3.29 s     ±3.20%         3.29 s         3.37 s

Comparison: 
parallel execution            0.37
sequential execution          0.30 - 1.21x slower +0.57 s

Memory usage statistics:

Name                    Memory usage
parallel execution         141.86 MB
sequential execution       198.36 MB - 1.40x memory usage +56.50 MB

**All measurements for memory usage were the same**
```

並列実行版(parallel execution)の方が逐次実行版(sequential execution)より1.21倍高速で，メモリ使用量も節約できています．

